Вопрос №1

Дима, привет еще раз!
У меня вопрос по тактике работы с исключениями в спринге ( обработку которых я должен сделать до понедельника).
Я опишу как я это понимаю и прошу сориентировать делать ли так, как я написал или делать по-другому.
В моем проекте в основном эксепшены могут возникать:
1. В сервисах, когда используется Oprtional<T> findBy...().orElseThrow(()-> new RepositoryException()) // or DaoException, orElseException...
2. В Custom репозитории и дао, когда используется getConnection(), preparedStatement.executeQuery()

Чтобы приложение не завершало работу, и информировало пользователя, что возникла ошибка и выдавало ее описание, я предлагаю:
1. Все проверяемые исключения по месту чекать, логгировать и перебрасывать свои исключения, называемые от уровня возникновения:
RepositoryException (которое extends RuntimeException); ServiceException и т.п.
2. В контроллерах все методы сервисов обворачивать в try{...}catch(RuntimeException e), и если поймано исключение, то добавлять атрибут 
к сессии или модели с описанием проблемы и переадресовывать на страницу для вывода таких ошибок (например, /error/5xx).

Что скажешь?

[22.10, 15:40] Dmytro
1) ошибка должна называться не по уровню возникновение, а идентифицировать проблему. Например: UserNotFoundException, OrderAlreadyExistException. Это для того чтобы в логах было сразу понятно что именно произошло. Абстрактный репощиториЕксепшин ничего особо не говорит кроме места возникновение. Для каждого случая должен быть свой ексепшин, но иногда один и тот же кастомный ексепшин может быть переиспользован, к примеру, BadRequestException, при неверных входных данных.
2) да но ловить надо не ранней а твой конкретный ексепшин. + посмотри что такое @ControllerAdvice, может удасться избавиться от ненужных трай кетчев
(понравилось: 1)​[22.10, 15:41]
    спасибо



Вопрос №2

Дима привет!
Почитал о Richardson Maturity Model
В моем приложении связке с CRUD планирую переименовать uri потакому приципу.
И, соответственно, изменить и добавять контроллеры, которые будут обрабатывать
запросы по ним:

CRUD	Description	HTTP	URL
-----------------------------------------
READ	Get all		GET		/units
READ	Get one		GET		/units/id
-		Get form 	GET		/units/form*	// only sends form for filing fields
CREATE	Create unit	POST	/units
-		Get form	GET		/units/id/form	// only form for update
UPDATE	Upd unit	PATCH	/units/id		// POST will be actually in app.
DELETE	Del unit	DELETE	/units/id
------------------------------------------
* Alishev named it as /units/new*

https://youtu.be/D58pIymCew4?list=PLAma_mKffTOR5o0WNHnY0mTjKxnCgSXrZ&t=551

[Вчера (16:49)] Dmytro
    привет, да, все ок



Вопрос №3

Дима, привет!
Вопрос по заданию "Сделать все по RMM, SOLID, Clean Code".
Я прочитал несколько статей по тому, как лучше всего написать контроллеры, посмотрел пример проекта,
который был рекомендован как образц проекта на спринге преподаваелем с курса ЕПАМ, образцы реализаций из
разных источников в интернете, но остались вопросы, т.к. даже на мой взгляд, в тех примерах не все
соответствует либо маппингу RMM, либо SOLID либо еще чему-то.
Чтобы не переделывать несколько раз одно и тоже, я прошу дать одобрение следующей схеме рефакторинга моего кода.
Сейчас все контроллеры выглядят одинаково:
    SomeController {
        private SomeService someService;
	    @...Mapping("/something")
	    public String doSomething(params) {
		return someService.doSomething(params);
	    }
	}
Интерфейсы методов сервисов (которые написаны специально для контроллеров) полностью совпадает с интерфейсом
методов контроллеров по передаваемым параметрам и возвращаемым значениям. Все методы этих сервисов возвращают
строку - название шаблона тимлиф. Сами методы не декомпозированы(длинные прстыни)
Я хочу сделать так:
1. В методах контроллеров будет присутствовать только логика, связанная с установкой аттрибутов для модели или сессии
    и возвращаемая ими строка будет указана явно в самом методе контроллера, а не так
    как сейчас: return someService.doSomething(params).
2. Методы сервисов будут декомпозированы, так, чтобы они по-максимуму делали что-то одно. При этом часть логики из их
    "простыней" будет выделена либо в отдельные вспомогательные методы, либо вообще перейдет в другие сервисы.
Что скажеш?


Я подумал, и могу ответить не гугля: работать будет и с интерфейсами и без в 3-х вариантах:
1. С интерфейсом спринг сам найдет реаизацию, создаст 1 бин, и везде его будет подставлять.
2. Без интерфейса, но если в файле конфигурации явно получить бин нужный @Bean бин, то все будет работать также хорошо
 как и в п.1.
3. Без интерфейса, в каждом случае внутри контроллера нужно будет SomeService someService = new SomeService()? -
будет бесполезная трата системных ресурсов и возможны ошибки связанные с доступом к несинхронизированным общим ресурсам,
если такие будут присутствовать в реализации этих сервисов.

Лучше всего в.1. т.к. он наиболее экономный, соответствует soliD и ожиданиям других программистов,
 которые будут смотреть в мой код.




